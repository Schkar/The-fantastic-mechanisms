Coś na mobilki


Kulkadane: Wektor, X, Y, Wektor prędkości, współczynnik prędkości

1. Obliczamy komponenty wektora predkości
Vx = współczynnik prędkości * cos(gamma) (gamma = W - 180)
Vy = współczynnik prędkości * sin(gamma)

X2 = X0 + Vx
Y2 = Y0 + Vy

2. Obliczenie wektora wyjściowego po uderzeniu

https://en.wikipedia.org/wiki/Elastic_collision#Two-dimensional

theta = W?
fi = rotacja?

V1X = v1*sin(theta - fi)*cos(fi + pi/2)

V1Y = v1*sin(theta - fi)*sin(fi + pi/2)

X3 = Xkolizji + V1X;
Y3 = Ykolizji + V1Y;



function BallObject(elasticity) {
  this.v = { x: 1, y: 20 }; // velocity: m/s^2
  this.m = 10; // mass: kg
  this.p = { x: 40, y: 0}; // position
  this.r = 15; // radius of obj
  this.cr = elasticity; // elasticity
}

function collide(obj) {
  obj.v.y = (obj.cr * floor.m * -obj.v.y + obj.m * obj.v.y) / (obj.m + floor.m);
  obj.v.y = (-obj.v.y + obj.v.y);
}

function update(obj, dt) {
  
  // over-simplified collision detection
  // only consider the floor for simplicity
  if ((obj.p.y + obj.r) > c.height) { 
     obj.p.y = c.height - obj.r;
     collide(obj);
  }
  
  obj.v.y = obj.v.y + g * dt;
  obj.p.x = obj.p.x + obj.v.x * dt * ppm;
  obj.p.y += obj.v.y * dt * ppm;
}
    fps = 60, // target frames per second
    ppm = 20, // pixels per meter
    g = 9.8, // m/s^2 - acceleration due to gravity
    objs = [],
    floor = {
      v: { x: 0, y: 0 }, // floor is immobile
      m: 5.9722 * Math.pow(10, 24) // mass of earth (probably could be smaller)
    },
    t = new Date().getTime();


setInterval(function() {
  
  var nt = new Date().getTime(),
      dt = (nt - t) / 1000;
  
  if (clr.checked) {
    ctx.clearRect(0, 0, c.width, c.height);
  }
  
  for (var i = 0; i < objs.length; i++) {
    update(objs[i], dt);
    draw(objs[i]);
  }
  
  t = nt;
  
}, 1000 / fps);

https://stackoverflow.com/questions/41469794/html-canvas-and-javascript-rotating-objects-with-collision-detection
<script>
        var context = document.getElementById('pageCanvas').getContext('2d');
        var angle = 0;
        function convertToRadians(degree) {
            return degree*(Math.PI/180);
        }

        function incrementAngle() {
            angle++;
            if(angle > 360) {
                angle = 0;
            }
        }

        function drawRandomlyColoredRectangle() {  
            <!-- clear the drawing surface -->
            context.clearRect(0,0,1280,720);
            <!-- you can also stroke a rect, the operations need to happen in order -->
            incrementAngle();
            context.save();                
            context.lineWidth = 10;  
            context.translate(200,200);
            context.rotate(convertToRadians(angle));
            <!-- set the fill style -->
            context.fillRect(-25,-25,50,50);
            context.strokeRect(-25,-25,50,50);                
            context.restore();
        }

        setInterval(drawRandomlyColoredRectangle, 20);
    </script>

    Move hit point to local space
First an alternative

There are many ways you can do it. The simplest way. When you calculate the cross product between a point and a line it will be negative if the point is right of the line and positive if left. If you then do each of the four sides in turn and they are all the same sign the point must be inside.

To get the cross product of a line and a point

//x1,y1,x2,y2   is a line
// px,py is a point
// first move line and point relative to the origin
// so that the line and point is a vector
px -= x1;
py -= y1;
x2 -= x1;
y2 -= y1;
var cross = x2 * py - y2 * px; 
if(cross < 0){ 
     // point left of line
}else if(cross > 0) {
    // point right of line
}else {
    // point on the line
}

A Quicker way.

But that is a lot of math for each object and each bullet.

The best way is to transform the bullet into the tanks local coordinate system then its just a simple matter of testing the bounds, left, right, top, bottom.

To do that you need to invert the tanks transformation matrix. Unfortunately the easy way to do that is currently still behind browser flags/prefixes so you need to create and manipulate the transformations in javascript. (Should not be too long till ctx.getTransform() is implemented across the board and fill a very needed performance hole in the canvas 2d API)
If ctx.getTransform is available

So you have a tank at x,y and rotated r and you draw it with

ctx.translate(x,y);
ctx.rotate(r);
// render the tank
ctx.fillRect(-20,-10,40,20); // rotated about center

The transform hold everything we need to do the calcs, all we need to do is invert it and then multiply the bullet with the inverted matrix

var tankInvMatrix = ctx.getTransform().invertSelf(); // get the inverted matrix

The bullet is at bx,by so create a DOMPoint

var bullet = new DOMPoint(bx,by);

Then for each tank transform the bullet with DOMMatrix.transformPoint

var relBullet = tankInvMatrix.transformPoint(bullet); // transform the point 
                                                      // returning the bullet 
                                                      // relative to the tank

Now just do the test in the tanks local coord space

if(relBullet.x > -20 && relBullet.x < 20 && relBullet.x > -10 && relBullet.x < 10){
      /// bullet has hit the tank
}

The Javascript way

Well until the becomes the norm you have to do it the long way. Using the same x,y,r for tank, bx,by for bullet.

// create a vector aligned to the tanks direction
var xdx = Math.cos(r);
var xdy = Math.sin(r);

// set the 2D API to the tank location and rotation
ctx.setTransform(xdx,xdy,-xdy,xdx,x,y);  // create the transform for the tank

// draw the tank
ctx.fillRect(-20,-10,40,20); // rotated about center

// create inverted matrix for the tank 
// Only invert the tank matrix once per frame

var d =  xdx * xdx - xdy * -xdy;
var xIx  = xdx / d;
var xIy  = -xdy / d;
// I am skipping c,d of the matrix as it is perpendicular to a,b
// thus c = -b and d = a
var ix = (-xdy * y - xdx * x) / d;
var iy = -(xdx * y - xdy * x) / d;

// For each bullet per tank
// multiply the bullet with the inverted tank matrix
// bullet local x & y
var blx = bx * xIx - by * xIy + ix;
var bly = bx * xIy + by * xIx + iy;

// and you are done.
if(blx > -20 && blx < 20 && bly > -10 && bly < 10){
      // tank and bullet are one Kaaboommmm 
}

Test to make sure it works

Too many negatives, xdx,xdy etc etc for me to be able to see if I got it correct (Turned out I put the wrong sign in the determinant) so here is a quick demo to show it in action and working.

Use the mouse to move over the tank body and it will show that it is hit in red. You could extend it easily to also hit the tank moving parts. You just need the inverse transform of the turret to get the bullet in local space to do the test.

Hide code snippet

// some tanks
var tanks = {
    tanks : [], // array of tanks
    drawTank(){  // draw tank function
        this.r += this.dr;
        this.tr += this.tdr;
        if(Math.random() < 0.01){
            this.dr = Math.random() * 0.02 - 0.01;
        }
        if(Math.random() < 0.01){
            this.tdr = Math.random() * 0.02 - 0.01;
        }
        if(Math.random() < 0.01){
            this.speed = Math.random() * 2 - 0.4;
        }
        var xdx = Math.cos(this.r);
        var xdy = Math.sin(this.r);
        
        // move the tank forward
        this.x += xdx * this.speed;
        this.y += xdy * this.speed;
        this.x = (this.x + canvas.width) % canvas.width;
        this.y = (this.y + canvas.height) % canvas.height;

        ctx.setTransform(xdx,xdy,-xdy,xdx,this.x,this.y);
        ctx.lineWidth = 2;
        ctx.fillStyle = "#F00";
        ctx.strokeStyle = "#080";
        if(this.hit){
            ctx.fillRect(-this.w / 2, -this.h /2, this.w, this.h);
            this.hit = false;
        }
        ctx.strokeRect(-this.w / 2, -this.h / 2, this.w, this.h);
        ctx.translate(-this.w /4, 0)
        ctx.rotate(this.tr);
        ctx.strokeRect(this.w / 4, - 2, this.w * 0.8, 4);
        ctx.strokeRect(-8, - 8, 16, 16);
        // invert the tank matrix
        var d =  (xdx * xdx) - xdy * -xdy;
        this.invMat[0] = xdx / d;
        this.invMat[1] = -xdy / d;
        // I am skipping c,d of the matrix as it is perpendicular to a,b
        // thus c = -b and d = a
        this.invMat[2] = (-xdy * this.y - xdx * this.x) / d;
        this.invMat[3] = -(xdx * this.y - xdy * this.x) / d;        
    },
    hitTest(x,y){ // test tank against x,y
        var blx = x * this.invMat[0] - y * this.invMat[1] + this.invMat[2];
        var bly = x * this.invMat[1] + y * this.invMat[0] + this.invMat[3];
        if(blx > -this.w / 2 && blx < this.w / 2 && bly > -this.h / 2 && bly < this.h / 2){
            this.hit = true;
        }        
    },
    eachT(callback){ // iterator
        for(var i = 0; i < this.tanks.length; i ++){ callback(this.tanks[i],i); }
    },
    addTank(x,y,r){  // guess what this does????
        this.tanks.push({
            x,y,r,
            dr : 0,  // turn rate
            tr : 0,  // gun direction
            tdr : 0, // gun turn rate
            speed : 0, // speed
            w : 40,
            h : 20,
            invMat : [0,0,0,0],
            hit : false,
            hitTest : this.hitTest,
            draw : this.drawTank,
        })
    },
    drawTanks(){ this.eachT(tank => tank.draw()); },
    testHit(x,y){ // test if point x,y has hit a tank
        this.eachT(tank => tank.hitTest(x,y));
    }
}


// this function is called from a requestAnimationFrame call back
function display() { 
    if(tanks.tanks.length === 0){
        // create some random tanks
        for(var i = 0; i < 100; i ++){
            tanks.addTank(
                Math.random() * canvas.width,
                Math.random() * canvas.height,
                Math.random() * Math.PI * 2
            );
        }
    }
    
    ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transform
    ctx.globalAlpha = 1; // reset alpha
    ctx.clearRect(0, 0, w, h);
    
    // draw the mouse
    ctx.fillStyle = "red";
    ctx.strokeStyle = "#F80";
    ctx.beginPath();
    ctx.arc(mouse.x,mouse.y,3,0,Math.PI * 2);
    ctx.fill();
    ctx.stroke();


    // draw the tanks    
    tanks.drawTanks();
    // test for a hit (Note there should be a update, then test hit, then draw as is the tank is hit visiualy one frame late)
    tanks.testHit(mouse.x,mouse.y);
}



//====================================================================================================
// Boilerplate code not part of answer ignore all code from here down
//====================================================================================================

var w, h, cw, ch, canvas, ctx, mouse, globalTime = 0, firstRun = true;
;(function(){
    const RESIZE_DEBOUNCE_TIME = 100;
    var  createCanvas, resizeCanvas, setGlobals, resizeCount = 0;
    createCanvas = function () {
        var c,cs;
        cs = (c = document.createElement("canvas")).style;
        cs.position = "absolute";
        cs.top = cs.left = "0px";
        cs.zIndex = 1000;
        document.body.appendChild(c);
        return c;
    }
    resizeCanvas = function () {
        if (canvas === undefined) {
            canvas = createCanvas();
        }
        canvas.width = innerWidth;
        canvas.height = innerHeight;
        ctx = canvas.getContext("2d");
        if (typeof setGlobals === "function") {
            setGlobals();
        }
        if (typeof onResize === "function") {
            if(firstRun){
                onResize();
                firstRun = false;
            }else{
                resizeCount += 1;
                setTimeout(debounceResize, RESIZE_DEBOUNCE_TIME);
            }
        }
    }
    function debounceResize() {
        resizeCount -= 1;
        if (resizeCount <= 0) {
            onResize();
        }
    }
    setGlobals = function () {
        cw = (w = canvas.width) / 2;
        ch = (h = canvas.height) / 2;
    }
    mouse = (function () {
        function preventDefault(e) {
            e.preventDefault();
        }
        var mouse = {
            x : 0,y : 0,w : 0,
            alt : false,
            shift : false,
            ctrl : false,
            buttonRaw : 0,
            over : false,
            bm : [1, 2, 4, 6, 5, 3],
            active : false,
            bounds : null,
            crashRecover : null,
            mouseEvents : "mousemove,mousedown,mouseup,mouseout,mouseover,mousewheel,DOMMouseScroll".split(",")
        };
        var m = mouse;
        function mouseMove(e) {
            var t = e.type;
            m.bounds = m.element.getBoundingClientRect();
            m.x = e.pageX - m.bounds.left + scrollX;
            m.y = e.pageY - m.bounds.top + scrollY;
            m.alt = e.altKey;
            m.shift = e.shiftKey;
            m.ctrl = e.ctrlKey;
            if (t === "mousedown") {
                m.buttonRaw |= m.bm[e.which - 1];
            } else if (t === "mouseup") {
                m.buttonRaw &= m.bm[e.which + 2];
            } else if (t === "mouseout") {
                m.buttonRaw = 0;
                m.over = false;
            } else if (t === "mouseover") {
                m.over = true;
            } else if (t === "mousewheel") {
                m.w = e.wheelDelta;
            } else if (t === "DOMMouseScroll") {
                m.w = -e.detail;
            }
            if (m.callbacks) {
                m.callbacks.forEach(c => c(e));
            }
            if ((m.buttonRaw & 2) && m.crashRecover !== null) {
                if (typeof m.crashRecover === "function") {
                    setTimeout(m.crashRecover, 0);
                }
            }
            e.preventDefault();
        }
        m.addCallback = function (callback) {
            if (typeof callback === "function") {
                if (m.callbacks === undefined) {
                    m.callbacks = [callback];
                } else {
                    m.callbacks.push(callback);
                }
            }
        }
        m.start = function (element) {
            if (m.element !== undefined) {
                m.removeMouse();
            }
            m.element = element === undefined ? document : element;
            m.mouseEvents.forEach(n => {
                m.element.addEventListener(n, mouseMove);
            });
            m.element.addEventListener("contextmenu", preventDefault, false);
            m.active = true;
        }
        m.remove = function () {
            if (m.element !== undefined) {
                m.mouseEvents.forEach(n => {
                    m.element.removeEventListener(n, mouseMove);
                });
                m.element.removeEventListener("contextmenu", preventDefault);
                m.element = m.callbacks = undefined;
                m.active = false;
            }
        }
        return mouse;
    })();
    // Clean up. Used where the IDE is on the same page.
    var done = function () {
        window.removeEventListener("resize", resizeCanvas)
        if(mouse !== undefined){
            mouse.remove();
        }
        document.body.removeChild(canvas);
        canvas = ctx = mouse = undefined;
    }
    function update(timer) { // Main update loop
        if(ctx === undefined){
            return;
        }
        globalTime = timer;
        display(); // call demo code
        //if (!(mouse.buttonRaw & 2)) {
            requestAnimationFrame(update);
        //} else {
        //    done();
        //}
    }
    setTimeout(function(){
        resizeCanvas();
        mouse.start(canvas, true);
        mouse.crashRecover = done;
        window.addEventListener("resize", resizeCanvas);
        requestAnimationFrame(update);
    },0);
})();

/**
  * Vector.js
  */

function Vector(x, y) {
	this.x = Number(x) || 0;
	this.y = Number(y) || 0;
}

Vector.arrow = function(start, dir, mag, ctx, lineCol) {
	if(mag === 0)
		return;
	
	var p1x = 5 * dir.y;
	var p1y = -5 * dir.x;
	
	var p2x = -5 * dir.y;
	var p2y = 5 * dir.x;
	
	var p0x = dir.x*mag - dir.x*5;
	var p0y = dir.y*mag - dir.y*5;
	
	ctx.save();
		ctx.lineWidth = 2;
		
		ctx.beginPath();
		ctx.moveTo(start.x, start.y);
		ctx.lineTo(start.x + p0x, start.y + p0y);
		ctx.lineTo(start.x + p0x + p1x, start.y + p0y + p1y);
		ctx.lineTo(start.x + dir.x*mag, start.y + dir.y*mag);
		ctx.lineTo(start.x + p0x + p2x, start.y + p0y + p2y);
		ctx.lineTo(start.x + p0x, start.y + p0y);
		ctx.closePath();
	
		ctx.strokeStyle = lineCol;
		ctx.stroke();
	ctx.restore();
};

Vector.prototype.set = function(x, y) {
	if(x instanceof Vector) {
		this.x = x.x;
		this.y = x.y;
	}
	else {
		this.x = Number(x) || this.x;
		this.y = Number(y) || this.y;
	}
	
	return this;
};

Vector.prototype.setAngle = function(ang) {
	var o = this.angle();
	this.rotate(-1*o);
	this.rotate(ang);
	return this;
};

Vector.prototype.scale = function(s) {
	s = Number(s) || 1;
	this.x *= s;
	this.y *= s;
	return this;
};

Vector.prototype.add = function(b, s) {
	s = Number(s) || 1;
	this.x += b.x*s;
	this.y += b.y*s;
	return this;
};

Vector.prototype.subtract = function(b, s) {
	s = Number(s) || 1;
	this.x -= b.x*s;
	this.y -= b.y*s;
	return this;
};

Vector.prototype.dot = function(b) {
	return (this.x*b.x + this.y*b.y);
};

Vector.prototype.magnitude = function() {
	return Math.sqrt(this.x*this.x + this.y*this.y);
};

Vector.prototype.rotate = function(ang) {
	var x = this.x*Math.cos(ang) + this.y*Math.sin(ang);
	var y = this.x*Math.sin(ang) - this.y*Math.cos(ang);
	
	this.x = x;
	this.y = -y;
	
	return this;
};

Vector.prototype.angle = function() {
	return Math.atan2(-this.y, this.x);
};

Vector.prototype.invert = function() {
	this.x = -this.x;
	this.y = -this.y;
	return this;
};

Vector.prototype.isNear = function(x, y, r) {
	var a = (this.x - x);
	var b = (this.y - y);
	var m = a*a + b*b;
	
	if(m <= r*r)
		return true;
	
	return false;
};

/**
  * Box.js
  */

function Box(position, width, height, ori, color) {
	this.position = position || new Vector();
	this.width = Number(width) || 1;
	this.height = Number(height) || 1;
	
	this.axes = new Array(2);
	this.axes[0] = new Vector(1, 0);
	this.axes[1] = new Vector(0, -1);
	
	if(Number(ori))
		this.rotate(ori);
		
	this.color = color || '240, 240, 240';
}

Box.prototype.move = function(vec) {
	if(vec instanceof Vector) {
		this.position.add(vec);
	}
};

Box.prototype.rotate = function(ang) {
	this.axes[0].rotate(ang);
	this.axes[1].rotate(ang);
};

Box.prototype.setAngle = function(ang) {
	this.axes[0].setAngle(ang);
	this.axes[1].setAngle(ang);
};

Box.prototype.isColliding = function(b) {
	var t = new Vector(b.position.x, b.position.y);
	t.subtract(this.position);
	var s1 = new Vector(t.dot(this.axes[0]), t.dot(this.axes[1]));
	t.set(this.position);
	t.subtract(b.position);
	var s2 = new Vector(t.dot(b.axes[0]), t.dot(b.axes[1]));
	
	var d = new Array(4);
	d[0] = this.axes[0].dot(b.axes[0]);
	d[1] = this.axes[0].dot(b.axes[1]);
	d[2] = this.axes[1].dot(b.axes[0]);
	d[3] = this.axes[1].dot(b.axes[1]);
	
	var ra = 0, rb = 0;
	
	ra = this.width * 0.5;
	rb = Math.abs(d[0])*b.width*0.5 + Math.abs(d[1])*b.height*0.5;
	if(Math.abs(s1.x) > ra+rb) {
		//delete t;
		//delete s1;
		//delete s2;
		//delete d;
		return 1;
	}
	
	ra = this.height * 0.5;
	rb = Math.abs(d[2])*b.width*0.5 + Math.abs(d[3])*b.height*0.5;
	if(Math.abs(s1.y) > ra+rb) {
		//delete t;
		//delete s1;
		//delete s2;
		//delete d;
		return 2;
	}
	
	ra = Math.abs(d[0])*this.width*0.5 + Math.abs(d[2])*this.height*0.5;
	rb = b.width*0.5;
	if(Math.abs(s2.x) > ra+rb) {
		//delete t;
		//delete s1;
		//delete s2;
		//delete d;
		return 3;
	}
	
	ra = Math.abs(d[1])*this.width*0.5 + Math.abs(d[3])*this.height*0.5;
	rb = b.height*0.5;
	if(Math.abs(s2.y) > ra+rb) {
		//delete t;
		//delete s1;
		//delete s2;
		//delete d;
		return 4;
	}
	
	//delete t;
	//delete s1;
	//delete s2;
	//delete d;
	return 0;
};

Box.prototype.updateCorners = function() {
	this.p1 = this.p1 ? this.p1.set(this.position) : new Vector(this.position.x, this.position.y);
	this.p2 = this.p2 ? this.p2.set(this.position) : new Vector(this.position.x, this.position.y);
	this.p3 = this.p3 ? this.p3.set(this.position) : new Vector(this.position.x, this.position.y);
	this.p4 = this.p4 ? this.p4.set(this.position) : new Vector(this.position.x, this.position.y);
	
	this.p1.subtract(this.axes[0], this.width * 0.5);
	this.p1.add(this.axes[1], this.height * 0.5);
	
	this.p2.add(this.axes[0], this.width * 0.5);
	this.p2.add(this.axes[1], this.height * 0.5);
	
	this.p3.add(this.axes[0], this.width * 0.5);
	this.p3.subtract(this.axes[1], this.height * 0.5);
	
	this.p4.subtract(this.axes[0], this.width * 0.5);
	this.p4.subtract(this.axes[1], this.height * 0.5);
};

Box.prototype.render = function(ctx) {
	this.updateCorners();
	
	ctx.save();
		ctx.beginPath();
		ctx.moveTo(this.p1.x, this.p1.y);
		ctx.lineTo(this.p2.x, this.p2.y);
		ctx.lineTo(this.p3.x, this.p3.y);
		ctx.lineTo(this.p4.x, this.p4.y);
		ctx.closePath();
		
		ctx.fillStyle = 'rgba(' + this.color + ', 0.5)';
		ctx.fill();
	ctx.restore();
};

Box.prototype.renderAxes = function(ctx) {
	Vector.arrow(this.position, this.axes[0], this.width * 0.5, ctx, 'rgba(126, 25, 24, 1.0)');
		
	Vector.arrow(this.position, this.axes[1], this.height * 0.5, ctx, 'rgba(126, 250, 65, 1.0)');
};

Box.prototype.renderWithRespect = function(b, ctx) {
	this.s1 = this.s1 ? this.s1.set(this.position) : new Vector(this.position.x, this.position.y);
	this.s2 = this.s2 ? this.s2.set(this.position) : new Vector(this.position.x, this.position.y);
	this.s3 = this.s3 ? this.s3.set(this.position) : new Vector(this.position.x, this.position.y);
	this.s4 = this.s4 ? this.s4.set(this.position) : new Vector(this.position.x, this.position.y);
	
	var wf = b.axes[0].dot(this.axes[0])*this.width*0.5 + b.axes[0].dot(this.axes[1])*this.height*0.5;
	var hf = b.axes[1].dot(this.axes[0])*this.width*0.5 + b.axes[1].dot(this.axes[1])*this.height*0.5;
	
	this.s1.subtract(b.axes[0], wf);
	this.s1.add(b.axes[1], hf);
	
	this.s2.add(b.axes[0], wf);
	this.s2.add(b.axes[1], hf);
	
	this.s3.add(b.axes[0], wf);
	this.s3.subtract(b.axes[1], hf);
	
	this.s4.subtract(b.axes[0], wf);
	this.s4.subtract(b.axes[1], hf);
	
	ctx.save();
		ctx.beginPath();
		ctx.moveTo(this.s1.x, this.s1.y);
		ctx.lineTo(this.s2.x, this.s2.y);
		ctx.lineTo(this.s3.x, this.s3.y);
		ctx.lineTo(this.s4.x, this.s4.y);
		ctx.closePath();
		
		ctx.fillStyle = 'rgba(' + b.color + ', 0.1)';
		ctx.fill();
	ctx.restore();
};


/** 
  * Main.js
  */

function init() {
	canvas = document.createElement('canvas');
	canvas.id = 'display';
	canvas.width = 500;
	canvas.height = 500;
	document.getElementById('stage').appendChild(canvas);
	
	ctx = canvas.getContext('2d');
	
	box1 = new Box(new Vector(100, 66), 50, 100, Math.PI/5, '0, 120, 180');
	box2 = new Box(new Vector(250, 250), 150, 60, 5*Math.PI/6, '199, 2, 230');
		
	dragging = false;
	rotating = false;
	dOff = new Vector();
	selected = null;
		 
	canvas.addEventListener('mousedown', mouseDown, false);
	canvas.addEventListener('mousemove', mouseMove, false);
	canvas.addEventListener('mouseup', mouseUp, false);
}

function getMouse(e) {
	var el = canvas, oX = 0, oY = 0;
	
	if(el.offsetParent !== undefined) {
		do {
			oX += el.offsetLeft;
			oY += el.offsetTop;
            el = el.offsetParent;
		} while(el !== null);
	}
	
	var mx = e.pageX - oX;
	var my = e.pageY - oY;
	
	return {x: mx, y: my};
}

function mouseDown(e) {
	var m = getMouse(e);
	var mx = m.x;
	var my = m.y;
	
	box1.updateCorners();
	box2.updateCorners();
	
	if( box1.p1.isNear(mx, my, 10) ) {
		rotating = true;
		dOff.set(box1.p1);
		dOff.subtract(box1.position);
		selected = box1;
		return;
	}
	
	if( box1.p2.isNear(mx, my, 10) ) {
		rotating = true;
		dOff.set(box1.p2);
		dOff.subtract(box1.position);
		selected = box1;
		return;
	}
	
	if( box1.p3.isNear(mx, my, 10) ) {
		rotating = true;
		dOff.set(box1.p3);
		dOff.subtract(box1.position);
		selected = box1;
		return;
	}
	
	if( box1.p4.isNear(mx, my, 10) ) {
		rotating = true;
		dOff.set(box1.p4);
		dOff.subtract(box1.position);
		selected = box1;
		return;
	}
	
	if( box1.position.isNear(mx, my, box1.width < box1.height? box1.width/2 : box1.height/2 ) ) {
		dragging = true;
		dOff.set(mx, my);
		dOff.subtract(box1.position);
		selected = box1;
		return;
	}
	
	if( box2.p1.isNear(mx, my, 10) ) {
		rotating = true;
		dOff.set(box2.p1);
		dOff.subtract(box2.position);
		selected = box2;
		return;
	}
	
	if( box2.p2.isNear(mx, my, 10) ) {
		rotating = true;
		dOff.set(box2.p2);
		dOff.subtract(box2.position);
		selected = box2;
		return;
	}
	
	if( box2.p3.isNear(mx, my, 10) ) {
		rotating = true;
		dOff.set(box2.p3);
		dOff.subtract(box2.position);
		selected = box2;
		return;
	}
	
	if( box2.p4.isNear(mx, my, 10) ) {
		rotating = true;
		dOff.set(box2.p4);
		dOff.subtract(box2.position);
		selected = box2;
		return;
	}
	
	if(  box2.position.isNear(mx, my, box2.width < box2.height? box2.width/2 : box2.height/2 ) ) {
		dragging = true;
		dOff.set(mx, my);
		dOff.subtract(box2.position);
		selected = box2;
		return;
	}
	
	if(selected) {
		selected = null;
	}
}

function mouseMove(e) {
	var m = getMouse(e);
	var mx = m.x;
	var my = m.y;
		
	if(rotating) {
		var n = new Vector(mx - selected.position.x, my - selected.position.y);
		var a1 = dOff.angle();
		var a2 = n.angle();
		
		selected.rotate(a2 - a1);
		
		dOff.set(n);
		
		//delete n;
	}
	else if(dragging) {
		selected.position.x = mx;
		selected.position.y = my;
	}
}

function mouseUp(e) {
	dragging = false;
	rotating = false;
	dOff.set(0, 0);
}

function update() {
	b1msg = '';
	b2msg = '';
	
	switch(box1.isColliding(box2)) {
		case 0:	b1msg = 'Blue collides with Pink!';
				break;
		case 1: b1msg = 'Separated by local X of Blue';
				break;
		case 2: b1msg = 'Separated by local Y of Blue';
				break;
		case 3: b1msg = 'Separated by local X of Pink';
				break;
		case 4: b1msg = 'Separated by local Y of Pink';
				break;
	}
	
	switch(box2.isColliding(box1)) {
		case 0:	b2msg = 'Pink collides with Blue!';
				break;
		case 1: b2msg = 'Separated by local X of Pink';
				break;
		case 2: b2msg = 'Separated by local Y of Pink';
				break;
		case 3: b2msg = 'Separated by local X of Blue';
				break;
		case 4: b2msg = 'Separated by local Y of Blue';
				break;
	}
}

function renderTranslation() {
	var t = new Vector(box2.position.x, box2.position.y);
	t.subtract(box1.position);
	var s1 = new Vector(t.dot(box1.axes[0]), t.dot(box1.axes[1]));
	t.set(box1.position);
	t.subtract(box2.position);
	var s2 = new Vector(t.dot(box2.axes[0]), t.dot(box2.axes[1]));
	
	var v1 = new Vector(box1.axes[0].x, box1.axes[0].y);
	var v2 = new Vector(box1.axes[1].x, box1.axes[1].y);
	var v3 = new Vector(box2.axes[0].x, box2.axes[0].y);
	var v4 = new Vector(box2.axes[1].x, box2.axes[1].y);
	
	if(s1.x < 0)
		v1.invert();
		
	if(s1.y < 0)
		v2.invert();
		
	if(s2.x < 0)
		v3.invert();
		
	if(s2.y < 0)
		v4.invert();
		
	ctx.save();
		ctx.lineWidth = 3;
		
		ctx.beginPath();
		ctx.moveTo(box1.position.x, box1.position.y);
		ctx.lineTo(box2.position.x, box2.position.y);
		ctx.closePath();
		
		ctx.strokeStyle = '#303030';
		ctx.stroke();
	ctx.restore();
	
	Vector.arrow(box1.position, v1, Math.abs(s1.x), ctx, 'rgba(255, 78, 0, 0.4)');
	Vector.arrow(box1.position, v2, Math.abs(s1.y), ctx, 'rgba(255, 78, 0, 0.4)');
	Vector.arrow(box2.position, v3, Math.abs(s2.x), ctx, 'rgba(250, 165, 115, 0.4)');
	Vector.arrow(box2.position, v4, Math.abs(s2.y), ctx, 'rgba(250, 165, 115, 0.4)');	
}

function renderOverlap() {
	var t = new Vector(box2.position.x, box2.position.y);
	t.subtract(box1.position);
	var s1 = new Vector(t.dot(box1.axes[0]), t.dot(box1.axes[1]));
	t.set(box1.position);
	t.subtract(box2.position);
	var s2 = new Vector(t.dot(box2.axes[0]), t.dot(box2.axes[1]));
	
	var v1 = new Vector(box1.axes[0].x, box1.axes[0].y);
	var v2 = new Vector(box1.axes[1].x, box1.axes[1].y);
	var v3 = new Vector(box2.axes[0].x, box2.axes[0].y);
	var v4 = new Vector(box2.axes[1].x, box2.axes[1].y);
	
	if(s1.x < 0)
		v1.invert();
		
	if(s1.y < 0)
		v2.invert();
		
	if(s2.x < 0)
		v3.invert();
		
	if(s2.y < 0)
		v4.invert();
	
	var v1sf1 = box1.width * 0.5;
	var v1sf2 = Math.abs(box1.axes[0].dot(box2.axes[0]))*box2.width*0.5 + Math.abs(box1.axes[0].dot(box2.axes[1]))*box2.height*0.5;
	
	var v2sf1 = box1.height * 0.5;
	var v2sf2 = Math.abs(box1.axes[1].dot(box2.axes[0]))*box2.width*0.5 + Math.abs(box1.axes[1].dot(box2.axes[1]))*box2.height*0.5;
	
	var v3sf1 = Math.abs(box2.axes[0].dot(box1.axes[0]))*box1.width*0.5 + Math.abs(box2.axes[0].dot(box1.axes[1]))*box1.height*0.5;
	var v3sf2 = box2.width * 0.5;
	
	var v4sf1 = Math.abs(box2.axes[1].dot(box1.axes[0]))*box1.width*0.5 + Math.abs(box2.axes[1].dot(box1.axes[1]))*box1.height*0.5;
	var v4sf2 = box2.height * 0.5;
	
	var sx, sy;
	
	ctx.save();
		
		ctx.lineWidth = 4;
		
		sx = box1.position.x;
		sy = box1.position.y;
		ctx.beginPath();
		ctx.moveTo(sx, sy);
		ctx.lineTo(sx + (v1.x*v1sf1), sy + (v1.y*v1sf1));
		ctx.closePath();
		ctx.strokeStyle = 'rgba(' + box1.color + ', 0.9)';
		ctx.stroke();
		
		sx = box1.position.x + v1.x*Math.abs(s1.x);
		sy = box1.position.y + v1.y*Math.abs(s1.x);
		v1.invert();
		ctx.beginPath();
		ctx.moveTo(sx, sy);
		ctx.lineTo(sx + (v1.x*v1sf2), sy + (v1.y*v1sf2));
		ctx.closePath();
		ctx.strokeStyle = 'rgba(' + box2.color + ', 0.9)';
		ctx.stroke();
		
		sx = box1.position.x;
		sy = box1.position.y;
		ctx.beginPath();
		ctx.moveTo(sx, sy);
		ctx.lineTo(sx + (v2.x*v2sf1), sy + (v2.y*v2sf1));
		ctx.closePath();
		ctx.strokeStyle = 'rgba(' + box1.color + ', 0.9)';
		ctx.stroke();
		
		sx = box1.position.x + v2.x*Math.abs(s1.y);
		sy = box1.position.y + v2.y*Math.abs(s1.y);
		v2.invert();
		ctx.beginPath();
		ctx.moveTo(sx, sy);
		ctx.lineTo(sx + (v2.x*v2sf2), sy + (v2.y*v2sf2));
		ctx.closePath();
		ctx.strokeStyle = 'rgba(' + box2.color + ', 0.9)';
		ctx.stroke();
		
		sx = box2.position.x;
		sy = box2.position.y;
		ctx.beginPath();
		ctx.moveTo(sx, sy);
		ctx.lineTo(sx + (v3.x*v3sf2), sy + (v3.y*v3sf2));
		ctx.closePath();
		ctx.strokeStyle = 'rgba(' + box2.color + ', 0.9)';
		ctx.stroke();
		
		sx = box2.position.x + v3.x*Math.abs(s2.x);
		sy = box2.position.y + v3.y*Math.abs(s2.x);
		v3.invert();
		ctx.beginPath();
		ctx.moveTo(sx, sy);
		ctx.lineTo(sx + (v3.x*v3sf1), sy + (v3.y*v3sf1));
		ctx.closePath();
		ctx.strokeStyle = 'rgba(' + box1.color + ', 0.9)';
		ctx.stroke();
		
		sx = box2.position.x;
		sy = box2.position.y;
		ctx.beginPath();
		ctx.moveTo(sx, sy);
		ctx.lineTo(sx + (v4.x*v4sf2), sy + (v4.y*v4sf2));
		ctx.closePath();
		ctx.strokeStyle = 'rgba(' + box2.color + ', 0.9)';
		ctx.stroke();
		
		sx = box2.position.x + v4.x*Math.abs(s2.y);
		sy = box2.position.y + v4.y*Math.abs(s2.y);
		v4.invert();
		ctx.beginPath();
		ctx.moveTo(sx, sy);
		ctx.lineTo(sx + (v4.x*v4sf1), sy + (v4.y*v4sf1));
		ctx.closePath();
		ctx.strokeStyle = 'rgba(' + box1.color + ', 0.9)';
		ctx.stroke();
		
	ctx.restore();
}



	{
		private var box1:SimpleSquare;
		private var c:Circle;
		private var t:TextField;
		
		public function DemoSAT5() {
			makeBoxes();
			t = new TextField(); addChild(t);
			t.autoSize = TextFieldAutoSize.LEFT
		}
		
		private function makeBoxes():void {
			box1 = new SimpleSquare(); addChild(box1);
			box1.prepareBox(
				new Point(200, 200), 
				new Point( 0, -50), 
				new Point( 50, 0), 
				new Point( 0, 50), 
				new Point( -50, 0)
			)
			box1.drawBox();
			box1.addEventListener(MouseEvent.MOUSE_DOWN, move);
			box1.addEventListener(MouseEvent.MOUSE_UP, move);
			
			c = new Circle(20); addChild(c); c.x = 100; c.y = 200
			c.addEventListener(MouseEvent.MOUSE_DOWN, move2);
			c.addEventListener(MouseEvent.MOUSE_UP, move2);
			stage.addEventListener(KeyboardEvent.KEY_DOWN, rotate);
		}
		
		private function move (e:MouseEvent):void {
			if (e.type == "mouseDown") {
				e.target.parent.startDrag();
				e.target.addEventListener(Event.ENTER_FRAME, update);
			}
			else if (e.type == "mouseUp") {
				e.target.parent.stopDrag();
				e.target.removeEventListener(Event.ENTER_FRAME, update);
			}
		}
		
		private function move2 (e:MouseEvent):void {
			if (e.type == "mouseDown") {
				e.target.startDrag();
				e.target.addEventListener(Event.ENTER_FRAME, update);
			}
			else if (e.type == "mouseUp") {
				e.target.stopDrag();
				e.target.removeEventListener(Event.ENTER_FRAME, update);
			}
		}
		
		private function update(e:Event):void {
			refresh()
		}
		
		private function rotate (e:KeyboardEvent):void {
			if (e.keyCode == Keyboard.R) {
				box1.addAngle(0.2); refresh()
			}
		}
		
		private function refresh():void {
			//prepare the vectors
			var v:Vector2d;
			var current_box_corner:Point;
			var center_box:Point = box1.getDot(0);
			
			var max:Number = Number.NEGATIVE_INFINITY;
			var box2circle:Vector2d = new Vector2d(c.x - center_box.x, c.y - center_box.y)
			var box2circle_normalised:Vector2d = box2circle.unitVector
			
			//get the maximum
			for (var i:int = 1; i < 5; i++) 
			{
				current_box_corner = box1.getDot(i)
				v = new Vector2d(
					current_box_corner.x - center_box.x , 
					current_box_corner.y - center_box.y);
				var current_proj:Number = v.dotProduct(box2circle_normalised)
				
				if (max < current_proj) max = current_proj;
			}
			trace(box2circle.magnitude, max, c.radius);
			trace(box2circle.magnitude - max - c.radius )
			if (box2circle.magnitude - max - c.radius > 0 && box2circle.magnitude > 0) t.text = "No Collision"
			else t.text = "Collision"
		}
	}

}


Thanks, great tutorial !

I think the last part is wrong though... If your circle is close to your square, a collision can be detected when there actually is none (and that's logical considering your code). I think that collision detection between circle and square is in fact not so simple using SAT. =]

Edit: It should work if you test your circle for each normal of your box and with each axis binding the center of your circle with one vertex of your box. So SAT algorithm seems to be more expensive when using circles/spheres after all. ;p

    You are right, I also found this mistake and I correct it by tesing the distance from box center to circle center from each normal of the box.

	
https://stackoverflow.com/questions/573084/how-to-calculate-bounce-angle
You might think that because your walls are aligned with the coordinate axes that it makes sense to write special case code (for a vertical wall, negate the x-coordinate of the velocity; for a horizontal wall, negate the y-coordinate of the velocity). However, once you've got the game working well with vertical and horizontal walls, probably the next thing you'll think is, "what about walls at arbitrary angles?" So it's worth thinking about the general case from the beginning.

In the general case, suppose your missile has velocity v and hits a wall with surface normal n.

Missile with vector v about to obliquely hit a wall with surface normal n.

Split v into components u perpendicular to the wall and w parallel to it.

Right-angled triangle with hypotenuse for v, short side u parallel to wall and long side w parallel to wall.

Where:

u = (v · n / n · n) n
w = v − u

Here, v · n is the dot product of the vectors v and n. See the link for an explanation of how to compute it. The dot product n · n evaluates to the square of the length of the normal vector; if you always keep your normals in the form of unit vectors then n · n = 1 and you can omit the division.

After bouncing, the component of motion parallel to the wall is affected by friction f, and the component perpendicular to the wall is affected by elasticity, which can be given in the form of a coefficient of restitution r.

So the velocity after the collision is v′ = f w − r u. In a perfectly elastic, frictionless collision, v′ = w − u; that is, the motion is reflected about the normal at the point of collision, as in the diagram given in Bill's answer.

This approach works just the same in three dimensions too.

(Obviously this is a very simplified notion of bouncing; it takes no account of angular momentum or deformation. But for many kinds of video games this kind of simplification is perfectly adequate.)
shareimprove this answer
	
edited Feb 11 '15 at 14:32
	
answered Feb 21 '09 at 15:17
Gareth Rees
46.2k692128
	
1 	 
	
I agree that starting with the special-case coding for vertical and horizontal walls is the wrong way to go. It's not a stepping stone to the correct route, but is instead a dead-end path. – Adam Kane Sep 15 '09 at 18:00
   	 
	
Hey guys, this is an awesome explanation, but I think it has a bug. Shouldn't it be u = -n ( v.n / n.n )? After all, u is in the reversed direction of n. – nullspace Mar 16 '11 at 23:51
1 	 
	
Am i the only one getting confused with the usage of v.n, instead of using v·n ? When i read n.n, my brain just exploded; thinking a normal had an element called normal. (im used to c++ too much?). – Rookie Dec 14 '12 at 15:10
   	 
	
To calculate surface normal n see this question: stackoverflow.com/questions/1243614/… – user5157912 Feb 4 '16 at 21:40
   	 
	
Thank you soo much, this worked perfect. If anyone else is wondering, you can do ux = (dotproduct(v,n)) * n, uy, wx and wy. – Ajay Dec 4 '16 at 7:11
   	 
	
excellent explanation. One query; When you hit a line it has two normal's....is there a good trick to knowing what one to use as n? (Visually its obvious, but I am thinking for code here) – darkflame Jan 8 at 16:05
   	 
	
@darkflame: If you can tell that an object hit a wall, then you can also tell which side of the wall it hit. – Gareth Rees Jan 8 at 19:36
   	 
	
I'm probably missing the obvious but I worked out where the hit happened with just a algorithm for detecting where two lines will cross. That just gave me the point on a (2d) line - no side involved there. In code my known information is start and end point of line hit, velocity of object moving and the point it hit on the line. I think the correct normal to pick is always the one with the opposite sign in x or y to the object moving. 